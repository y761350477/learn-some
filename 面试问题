1. 线程的实现方式?
三种:
    1. 继承Thread类;
    2. 实现Runnable接口, 重写run方法;
    3. executor线程池;

2. 重写和重载的区别?
    1. 重写是子类对父类方法的拓展, 特点是方法名相同, 参数相同, 返回类型相同;
    2. 重载是指一个类有两个或者多个相同的方法名, 而参数不同的情况;

3. 什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？
    1. Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
    2. Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

4. JDK 和 JRE 的区别是什么？
    JDK包含JRE和一些常用的工具(编译器、调试器)来供开发者开发、编译和运行java程序, 而JRE中有重要的 JVM（Java虚拟机）、一些运行的类库 等东西。

5. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
    1. “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
　　2. Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
    3. 可以在子类中编写父类的private方法, 但是不必满足重写的特点, 即可以有不同的参数, 不同的返回类型.

6. 是否可以在static环境中访问非static变量？
    不可以static修饰的变量是静态绑定的, 即编译期绑定, 而非static修饰的变量, 是运行期动态绑定.

7. Java支持的数据类型有哪些？什么是自动拆装箱？
    基本类型(四类八种): 整型类型、浮点类型、布尔类型、字符类型;
    引用数据类型： 首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。而包装类就属于引用类型，
    自动拆箱和装箱指的是基本数据中的整型和浮点型的包装类的相互转换, int -> Integer是装箱, Integer -> int是拆箱;

8. Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
    1. 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
    2. Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
    3. Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。

9. Java支持多继承么？
    Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。

10. 接口和抽象类的区别是什么？
共同点:
    1. 不能被实例化;
    2. 包含抽象方法;
区别:
    1. 抽象类可以默认的方法实现, 而接口是完全的抽象;
    2. 抽象类可以有构造器, 而接口没有;
    3. 抽象类可以有main方法, 而接口没有;
    4. 抽象类的方法可以有多种修饰, 而接口只能默认public修饰;

11. 什么是值传递和引用传递？
    1. 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.
    2. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身. 所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递

12. 进程和线程的区别?
    进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

13. 概括的解释下线程的几种可用状态?
    1. 五个状态  新建状态  -- 可运行状态  -- 运行状态  -- 阻塞状态 -- 销毁状态
    2. 阻塞状态:
        1. 等待阻塞：使用wait()，然后再等待队列里面呆着。等待依次被调用、
        2. 同步阻塞：调用了某个带锁的方法，当前锁被其他线程给拿到了，就需要等待其他线程用完，然后再拿到该锁，
        3. 其他阻塞：比如 执行了 sleep、或者 join 方法，使之线程进入了睡眠或者要等待别的线程执行完才轮到自己。

14. 同步方法和同步代码块的区别是什么？
    1. 同步方法默认用this或者当前类class对象作为锁；
    2. 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；

15. 什么是死锁(deadlock)？
    两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。

16. 如何确保N个线程可以访问N个资源同时又不导致死锁？
    使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

17. Java集合类框架的基本接口有哪些？
    集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。
        Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：
    　　Collection：代表一组对象，每一个对象都是它的子元素。
        Set：不包含重复元素的Collection。
    　　List：有顺序的collection，并且可以包含重复元素。
    　　Map：可以把键(key)映射到值(value)的对象，键不能重复.

18. 为什么集合类没有实现Cloneable和Serializable接口？
    克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化

19. 什么是迭代器(Iterator)？
    Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。

20. Iterator和ListIterator的区别是什么？
    1. Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
    2. Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
    3. ListIterator继承了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

21. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？
    Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。
    1. java.util包下面的所有的集合类都是快速失败的，快速失败的迭代器会抛出ConcurrentModificationException异常
    2. java.util.concurrent包下面的所有的类都是安全失败的。，而安全失败的迭代器永远不会抛出这样的异常。

22. Java中的HashMap的工作原理是什么？
    HashMap的底层是用hash数组和单向链表实现的，当调用put方法是，首先计算key的hashcode，定位到合适的数组索引，然后再在该索引上的单向链表进行循环遍历用equals比较key是否存在，如果存在则用新的value覆盖原值，如果没有则在链头保存该值。HashMap的两个重要属性是容量capacity和加载因子loadfactor，默认值分布为16和0.75，当容器中的元素个数大于 capacity*loadfactor时，容器会进行扩容resize 为2n，在初始化Hashmap时可以对着两个值进行修改，负载因子0.75被证明为是性能比较好的取值，通常不会修改，那么只有初始容量capacity会导致频繁的扩容行为，这是非常耗费资源的操作，所以，如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。

23. hashCode()和equals()方法的重要性体现在什么地方？
    Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。

24. HashMap和Hashtable有什么区别？
    HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
　　1. HashMap允许键和值是null，而Hashtable不允许键或者值是null。
　　2. Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
　　3. HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
　　4. 一般认为Hashtable是一个遗留的类.

25. SpringMvc的原理流程?
    ViewReslover